<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Advent Of Code 2021 Days 6-10 | Dave Bartram Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Advent Of Code 2021 Days 6-10" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Advent of Code 2021 Days 6-10" />
<meta property="og:description" content="Advent of Code 2021 Days 6-10" />
<link rel="canonical" href="http://localhost:4000/2022/01/05/advent-of-code-2021-days-6-10.html" />
<meta property="og:url" content="http://localhost:4000/2022/01/05/advent-of-code-2021-days-6-10.html" />
<meta property="og:site_name" content="Dave Bartram Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-05T13:45:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Advent Of Code 2021 Days 6-10" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-05T13:45:39+00:00","datePublished":"2022-01-05T13:45:39+00:00","description":"Advent of Code 2021 Days 6-10","headline":"Advent Of Code 2021 Days 6-10","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/01/05/advent-of-code-2021-days-6-10.html"},"url":"http://localhost:4000/2022/01/05/advent-of-code-2021-days-6-10.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Dave Bartram Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dave Bartram Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Advent Of Code 2021 Days 6-10</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-01-05T13:45:39+00:00" itemprop="datePublished">Jan 5, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="advent-of-code-2021-days-6-10">Advent of Code 2021 Days 6-10</h1>

<p><img src="/images/pexels-photo-6211095.jpeg" alt="christmas tree decorated with baubles and garland" /></p>

<p>Welcome back to some more <a href="http://adventofcode.com/2021/">Advent of Code 2021</a>!</p>

<p>These posts will be quite brief, just a few thoughts on each puzzle and the Python 3 code I used to solve it. All code on Github <a href="https://git.io/JmAvJ">here</a>. The code below is for Part 2 of each day, which often incorporates Part 1 in some way.</p>

<h2 id="day-6---lanternfish">Day 6 - <a href="https://adventofcode.com/2021/day/6">Lanternfish</a></h2>

<h3 id="thoughts">Thoughts</h3>

<p>Here we are dealing with exponential growth of a population of lanternfish. Each lanternfish has its own “timer”, counting down by 1 for each day that passes. The day after a lanternfish reaches 0 days on its timer, it spawns a new lanternfish with 8 days on its timer, and resets its own timer to 8 days.</p>

<p>Part 1 of the puzzle was to find out how many lanternfish there are after 80 days. While you’re doing part 1, you don’t know what part 2 is going to ask you. The example for part 1 shows the lanternfish represented as a list of timer values, one value for each fish.</p>

<p>My instinct was that the order of the lanternfish didn’t matter, so there was no need to keep track of individual lanternfish. Fortunately, part 2 only asked for the number of lanternfish after 256 days, rather than switching to a problem where the order mattered!</p>

<p>Basically the question was trying to trick you into representing lanternfish individually, and thus gobbling up all your computer’s memory due to the exponential rate of growth. Instead, the code below tracks the population of lanternfish with each timer value. This is done with a <code class="language-plaintext highlighter-rouge">defaultdict</code> from timer value to population. The <code class="language-plaintext highlighter-rouge">defaultdict</code> returns 0 if the key isn’t found, which saves having to initialise populations of zero in each state.</p>

<h3 id="python-code">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

<span class="n">counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">newstate</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

    

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">8</span><span class="p">:</span>
            <span class="n">newstate</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">t</span><span class="o">==</span><span class="mi">6</span><span class="p">:</span>
            <span class="n">newstate</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newstate</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">newstate</span>

<span class="n">generations</span> <span class="o">=</span> <span class="mi">256</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">generations</span><span class="p">):</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">advance</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">.</span><span class="n">values</span><span class="p">()))</span>
</code></pre></div></div>
<p>Day 7 - <a href="https://adventofcode.com/2021/day/7">The Treachery of Whales</a>
———————————————————————-</p>

<h3 id="thoughts-1">Thoughts</h3>

<p>Crab submarines can only move horizontally. Their own limitations are represented in their technology, a salutary lesson for any software developer. Or maybe I’m reading too much into it.</p>

<p>We have many crab submarines at different horizontal positions, and we want to find the minimum fuel cost required to bring them all into alignment. The fuel cost of moving a crab submarine is based on triangular numbers - the first step costs 1 fuel, the second step costs 2, and so on. So moving from position 13 to 17 would cost (1+2+3+4) = 10 fuel.</p>

<p>Moving <code class="language-plaintext highlighter-rouge">n</code> steps therefore costs <code class="language-plaintext highlighter-rouge">0.5(n)(n+1)</code> units of fuel, thanks to the well known formula for <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular numbers</a> due to the great <a href="https://letstalkscience.ca/educational-resources/backgrounders/gauss-summation">Carl Friedrich Gauss</a>.</p>

<p>What you see below is a brute force solution to the minimisation problem. The code simply iterates through each candidate position <code class="language-plaintext highlighter-rouge">x</code>, and works out the total fuel cost of aligning all the crab submarines at that position.</p>

<p>There are of course many improvements that could be made here. The total cost function is convex, so gradient descent would do a good job of finding the minimum.</p>

<p>Furthermore, it <a href="https://www.reddit.com/r/adventofcode/comments/rawxad/2021_day_7_part_2_i_wrote_a_paper_on_todays/">can be shown</a> that the optimum position lies within 0.5 of the mean of the initial positions. If you’re willing to follow a proof of that or take it on faith, you can solve this problem by checking only two values. Try <code class="language-plaintext highlighter-rouge">cost(floor(mean))</code> and <code class="language-plaintext highlighter-rouge">cost(ceil(mean))</code>, and take the lowest, which will be the overall minimum fuel cost.</p>

<p>(I’m actually a bit suspicious of the continuous calculus that goes into some “proofs” of the result that the optimum position lies within 0.5 of the mean, but the result appears to be true and can be shown without calculus, albeit it gets a bit messy).</p>

<h3 id="python-code-1">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">sum_fuel_costs</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">position</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>

<span class="n">min_cost</span> <span class="o">=</span> <span class="n">sum_fuel_costs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#brute force solution
</span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">sum_fuel_costs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
        <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span>

<span class="k">print</span><span class="p">(</span><span class="n">min_cost</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="day-8---seven-segment-search">Day 8 - <a href="https://adventofcode.com/2021/day/8">Seven Segment Search</a></h2>

<h3 id="thoughts-2">Thoughts</h3>

<p>This is a fun one!</p>

<p>We have a bunch of badly mis-wired <a href="https://en.wikipedia.org/wiki/Seven-segment_display">seven-segment displays</a> to deal with.</p>

<p>The displays represent the digits 0-9 as shown in the diagram below, with segments labelled a to g.</p>

<p><img src="/images/7segmentdisplay-1.jpg" alt="" /></p>

<p>For each 4 digit display in the input, we get a list of what all ten possible digits look like, plus the four digits the display is actually trying to show. Each display is miswired in a different way, so the 10 possible digits will not look like the above diagram! Each display always lights up the correct number of segments, but the segments have been mixed up in a consistent way. For example, a certain display might light up segment <code class="language-plaintext highlighter-rouge">f</code> <em>every time</em> it is supposed to light up segment <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>While this mapping will be consistent <em>within</em> a given display, each display is mis-wired <em>differently</em>. Each line of the input is effectively its own mini-puzzle that needs to be solved, independent of the other lines.</p>

<p>The scrambled seven-segment displays are represented by strings, for example <code class="language-plaintext highlighter-rouge">febca</code>, showing which segments are lit. <code class="language-plaintext highlighter-rouge">febca</code> would represent the following display:</p>

<p><img src="/images/febca.jpg" alt="" /></p>

<p>Let’s look at an example line of our input, representing various configurations of a single mis-wired display:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>febca cfagb ecbafd efdcbg cbegdfa fg bgafec gfae acgdb gfc | cgf facdeb ecgfdb afcbge
</code></pre></div></div>

<p>On the left of the <code class="language-plaintext highlighter-rouge">|</code> character we have all the digits 0-9, as they are shown on this mis-wired display. These could be in <em>any order</em>.</p>

<p>On the right of the <code class="language-plaintext highlighter-rouge">|</code> character we have the 4 digit output that we need to decode.</p>

<p>Consider the display <code class="language-plaintext highlighter-rouge">gfc</code>. This can <em>only</em> represent the digit 7, because 7 is the only digit where exactly 3 segments are lit. This means that the first digit of the output, <code class="language-plaintext highlighter-rouge">cgf</code>, must be 7. Notice that the order of the characters doesn’t matter - if the same segments are lit, the same digit is being displayed. This is one of the reasons my solution makes heavy use of sets - sets do not have any internal ordering. <code class="language-plaintext highlighter-rouge">{g,f,c}</code> and <code class="language-plaintext highlighter-rouge">{c,g,f}</code> are identical sets.</p>

<p>In fact I use <code class="language-plaintext highlighter-rouge">frozenset</code>s because they are immutable and hashable, and thus can be used as keys for a <code class="language-plaintext highlighter-rouge">defaultdict</code>.</p>

<p>We can decode the entire output just by thinking about sets of segments which are lit. At no point do we actually need to figure out exactly <em>how</em> the segments are mis-wired.</p>

<p>Firstly let’s organise the digits by the number of segments lit, with a quick glance at the diagram above.</p>

<p><img src="/images/segments_1.jpg" alt="" /></p>

<p><img src="/images/segments_2.jpg" alt="" /></p>

<p><img src="/images/segments_3.jpg" alt="" /></p>

<p>The digits 1, 4, 7, and 8 can be identified immediately by the number of segments lit.</p>

<p>There are a number of ways to identify the remaining digits, I used the following logic just because it was the first system that occurred to me which would work.</p>

<p>Compare the unidentified sets of segments with the ones that have already been identified as 7 and 4.</p>

<p>First consider 2, 3 and 5. Each of these has exactly five segments lit.</p>

<p><img src="/images/shared_segs_1.jpg" alt="" /></p>

<ul>
  <li>Only 3 has exactly three segments in common with 7</li>
  <li>Only 5 has exactly three segments in common with 4</li>
  <li>The other five-segment digit must represent 2</li>
</ul>

<p>Now repeat the process with 0, 6 and 9, which all have exactly six segments lit.</p>

<p><img src="/images/shared_segs_2.jpg" alt="" /></p>

<ul>
  <li>Only 6 has exactly two segments in common with 7</li>
  <li>Only 9 has exactly four segments in common with 4</li>
  <li>The other six-segment display must represent 0</li>
</ul>

<p>At this point we have identified how all of the digits 0-9 are represented on that particular display, and can decode the output. The final solution to the puzzle is just the sum of all the decoded outputs. Remember we need to repeat the decoding process for each row in our input, since each display is mis-wired in a different way.</p>

<p>Not again that this solution doesn’t actually determine how the individual segments in each display are mis-wired. Does <code class="language-plaintext highlighter-rouge">f</code> get lit instead of <code class="language-plaintext highlighter-rouge">a</code>? Does <code class="language-plaintext highlighter-rouge">b</code> get lit instead of <code class="language-plaintext highlighter-rouge">c</code>? Does <code class="language-plaintext highlighter-rouge">g</code> get lit correctly? Not a clue, this solution assigns sets of lit segments to digits without needing to answer any such questions.</p>

<h3 id="python-code-2">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>

    <span class="n">signals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">)</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">signal</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="n">output</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>

    <span class="n">signals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">outputs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s">'.'</span><span class="p">)</span>
    <span class="n">segs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">:</span>
        <span class="n">segs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)].</span><span class="n">append</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="s">'1'</span>
                
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="s">'4'</span>
                
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="s">'7'</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="s">'8'</span>

    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
        <span class="n">overlap_with_7</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">overlap_with_4</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">overlap_with_7</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="s">'3'</span>
        
        <span class="k">elif</span> <span class="n">overlap_with_4</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="s">'5'</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="s">'2'</span>

    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
        <span class="n">overlap_with_7</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">overlap_with_4</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">overlap_with_7</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="s">'6'</span>
            
        <span class="k">elif</span> <span class="n">overlap_with_4</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="s">'9'</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decoder</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="s">'0'</span>
        
    
    <span class="k">return</span> <span class="n">decoder</span>



<span class="k">def</span> <span class="nf">decode_outputs</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span><span class="n">outputs</span><span class="p">):</span>

    <span class="n">decoded_outputs</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">signal</span><span class="p">,</span><span class="n">output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">decoded_output</span> <span class="o">=</span> <span class="s">''</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">decoded_output</span> <span class="o">+=</span> <span class="n">decoder</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        
        <span class="n">decoded_outputs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">decoded_output</span><span class="p">))</span>
        
    
    <span class="k">return</span> <span class="n">decoded_outputs</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">decode_outputs</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span><span class="n">outputs</span><span class="p">)))</span>
</code></pre></div></div>
<p>Day 9 - <a href="https://adventofcode.com/2021/day/4">Smoke Basin</a>
———————————————————-</p>

<h3 id="thoughts-3">Thoughts</h3>

<p>Here we are dealing smoke, regarded as a fluid that flows to the lowest point of the area it is in. The height map of the region is represented by a grid of integers. The integers, ranging from 0 to 9, represent the height of that particular point on the grid.</p>

<p>In part 1 we have to identify <strong>low points</strong> - points which have a lower height than all adjacent points.</p>

<p>In part 2 we are told that a <strong>basin</strong> is a set of points that would flow down to the same low point. The input is constructed such that every basin has only a single low point. All points lie in a single basin except points with height 9, which are not considered to lie in any basin.</p>

<p>Our goal is to find the 3 largest basins, and multiply the number of points in each basin together.</p>

<p>I solved this by building a recursive function which would label every point with the <strong>basin ID</strong> of the low point that it drains to. High points (where height=9) are assigned a basin ID of -1, to represent that high points are not in any basin.</p>

<p>To find the basin ID of each point, I use a recursive function <code class="language-plaintext highlighter-rouge">get_basin_ID</code>. This function assigns any high point a basin ID of -1, and returns the basin ID of a point if already known. If the basin ID of the point is not yet known, the function recurses, considering the lowest point adjacent to the original point. Eventually the function will either reach a point whose basin ID we already know, or a low point we have not yet assigned a basin ID to. In the latter case, we assign a new basin ID to the low point.</p>

<p>Once every point has been assigned a basin ID, we simply count the number of points with a given ID to find the basin size, find the three largest basins, and multiply their sizes together.</p>

<h3 id="alternative-solution---flood-fill">Alternative Solution - Flood Fill</h3>

<p>Now it turns out the above is actually excessive work, since all we need to do is find the size of each basin. The individual heights inside the basin are actually irrelevant - a basin can be defined as <strong>any region bounded by points with height 9.</strong> As an alternative solution, I implemented a <a href="https://github.com/DavidBartram/advent-of-code/blob/main/2021/day09-2-floodfill.py">Flood Fill</a> which starts at a low point and fills the surrounding basin with 9s, counting the points as it goes along.</p>

<h3 id="python-code-basin-id-solution">Python Code (basin ID solution)</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>

<span class="c1"># Since all the grid heights are between 0 and 9, 100 is a suitable default value
</span><span class="n">grid</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>

<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">neighbour_coords</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="c1">#returns a list of coords of points adjacent to (i,j) in the grid
</span>    <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">dy</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">:</span> <span class="c1">#default value is 100 if (i+dx,j_dy) is not already in grid
</span>            <span class="n">coords_list</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">dy</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">coords_list</span>

<span class="k">def</span> <span class="nf">get_basin_ID</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">basin_IDs</span><span class="p">):</span>
    <span class="c1">#recursive function to calculate the basin ID of a grid position (i,j)
</span>    <span class="c1">#high points (height=9) will be assigned basin ID = -1
</span>    <span class="c1">#other points will be assigned the same ID as the low point of the basin they are in
</span>
    <span class="k">if</span> <span class="n">basin_IDs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1">#if the basin ID of the point (i,j) is already known, return the known value
</span>        <span class="k">return</span> <span class="n">basin_IDs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1">#assign high points a basin ID of -1
</span>        <span class="n">basin_IDs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">else</span><span class="p">:</span>

        <span class="c1">#find the value and coords of the lowest point neighbouring (i,j)
</span>
        <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">neighbour_coords</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">neigh_vals</span> <span class="o">=</span> <span class="p">{</span><span class="n">grid</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neigh_coords</span><span class="p">}</span>

        <span class="n">min_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neigh_vals</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">min_coords</span> <span class="o">=</span> <span class="n">neigh_vals</span><span class="p">[</span><span class="n">min_value</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
            <span class="c1">#if (i,j) is a new low point, we need to assign it a new basin ID
</span>            <span class="n">new_basin_ID</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">basin_IDs</span><span class="p">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">basin_IDs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_basin_ID</span>
            <span class="c1">#print('new basin ID ', new_basin_ID)
</span>            <span class="k">return</span> <span class="n">new_basin_ID</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if (i,j) is not known, and is not a new low point
</span>            <span class="c1">#recursively call the function for the coords of the lowest neighbouring point
</span>            <span class="c1">#this recursion will eventually reach a previously known value or a new low point
</span>            <span class="c1">#in either case the basin ID of the original point will match this value
</span>            <span class="k">return</span> <span class="n">get_basin_ID</span><span class="p">(</span><span class="n">min_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">basin_IDs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_basins</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="c1">#populates a dictionary where the keys are the coordinates on the grid and the values are the basin IDs
</span>    <span class="c1">#high points (height=9) will be assigned basin ID = -1
</span>    <span class="c1">#other points will be assigned the same ID as the low point of the basin they are in
</span>    <span class="n">basin_IDs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#-2 is the ID of any grid position that has not been assigned a basin yet
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="c1">#print('grid coords ', (i,j))
</span>            <span class="n">basin_IDs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">get_basin_ID</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">basin_IDs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">basin_IDs</span>
    

<span class="k">def</span> <span class="nf">three_largest_basins</span><span class="p">(</span><span class="n">basin_IDs</span><span class="p">):</span>
    <span class="c1">#The high points (height=9) were assigned basin ID = -1
</span>    <span class="c1">#high points are not in any basin so should not be counted
</span>    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">basin_IDs</span><span class="p">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">counts_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="p">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="p">.</span><span class="n">mul</span><span class="p">,</span><span class="n">counts_list</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

<span class="n">basin_IDs</span> <span class="o">=</span> <span class="n">find_basins</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

<span class="n">total</span> <span class="o">=</span> <span class="n">three_largest_basins</span><span class="p">(</span><span class="n">basin_IDs</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="python-code-flood-fill-solution">Python Code (flood fill solution)</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>

<span class="c1"># Since all the grid heights are between 0 and 9, 10 is a suitable default value
# When the grid dictionary is asked to look up coords beyond the grid, it will return 10
# this ensures that coords beyond the grid will result in a value lower than coords within the grid
</span><span class="n">grid</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">neighbours</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">neigh_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">=</span> <span class="n">step</span>
        <span class="n">neigh_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">dy</span><span class="p">)])</span>
    
    <span class="k">return</span> <span class="n">neigh_list</span>

<span class="k">def</span> <span class="nf">neighbour_coords</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="c1">#returns a list of coords of points adjacent to (i,j) in the grid
</span>    <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">dy</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">:</span> <span class="c1">#default value is 10 if (i+dx,j_dy) is not already in grid
</span>            <span class="n">coords_list</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">dy</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">coords_list</span>

<span class="k">def</span> <span class="nf">find_low_points</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">low_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">grid</span><span class="p">)):</span>
                <span class="n">low_points</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">low_points</span>

<span class="k">def</span> <span class="nf">flood_fill_and_count</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="c1">#starting with a point (x,y) that is in a basin (e.g. the low point)
</span>    <span class="c1">#count all the points in that basin
</span>    <span class="c1">#note that every basin is entirely surrounded by points with height 9
</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1">#stop if you've reached the edge of the basin
</span>        <span class="c1">#or a point that's already been counted (see below)
</span>        <span class="k">return</span> <span class="n">count</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">#count this point
</span>        <span class="n">grid</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1">#flood fill with 9s, prevents counting this point again
</span>
        <span class="c1">#recursively count the neighbouring points
</span>        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">neighbour_coords</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">flood_fill_and_count</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="n">grid</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">count</span>

<span class="k">def</span> <span class="nf">find_basin_sizes</span><span class="p">(</span><span class="n">low_points</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="n">basin_sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">low_points</span><span class="p">:</span>
        <span class="n">basin_sizes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">flood_fill_and_count</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">grid</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">basin_sizes</span>

<span class="k">def</span> <span class="nf">solve_puzzle</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">lps</span> <span class="o">=</span> <span class="n">find_low_points</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="n">basin_sizes</span> <span class="o">=</span> <span class="n">find_basin_sizes</span><span class="p">(</span><span class="n">lps</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="p">.</span><span class="n">mul</span><span class="p">,</span><span class="nb">sorted</span><span class="p">(</span><span class="n">basin_sizes</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">solve_puzzle</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="day-10---syntax-scoring">Day 10 - <a href="https://adventofcode.com/2021/day/10">Syntax Scoring</a></h2>

<h3 id="thoughts-4">Thoughts</h3>

<p>OK, a parsing puzzle. Not my strongest area, and interesting to learn about!</p>

<p>In part 2 our goal is simple, correct the unbalanced brackets. There are four kinds of bracket: <code class="language-plaintext highlighter-rouge">(), [], {}</code> and <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>. Of course these brackets can be nested.</p>

<p>An example string in the input would be <code class="language-plaintext highlighter-rouge">{&lt;{}]&gt;}</code> . Strings like these are called <strong>corrupted</strong>, because the character <code class="language-plaintext highlighter-rouge">]</code> appears without an opening <code class="language-plaintext highlighter-rouge">[</code>. In part 2 we need to identify corrupted strings, but we can subsequently ignore them.</p>

<p>Another example might be <code class="language-plaintext highlighter-rouge">{&lt;(([]))</code>. This string is merely <strong>incomplete</strong>, it can be corrected by appending the <strong>completion string</strong> <code class="language-plaintext highlighter-rouge">&gt;}</code> at the end to close the unbalanced brackets. For incomplete strings, we calculate a <strong>score</strong> based on the on the completion string.</p>

<p>The score is determined by considering the completion string character-by-character. Start with a total score ofÂ <code class="language-plaintext highlighter-rouge">0</code>. Then, for each character, multiply the total score by 5 and then increase the total score by the point value given for the character below:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">")"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1 point"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"]"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2 points"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"}"</span><span class="p">:</span><span class="w"> </span><span class="s2">"3 points"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"&gt;"</span><span class="p">:</span><span class="w"> </span><span class="s2">"4 points"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>To solve this problem I implemented a stack based parser function called <code class="language-plaintext highlighter-rouge">completion_string</code>. The stack is implemented as a list unimaginatively titled <code class="language-plaintext highlighter-rouge">stack.</code> The parser moves through the line, one character at a time:</p>

<ul>
  <li>If the current character is an opening bracket character of any kind, that character gets pushed onto the top of the stack.</li>
  <li>
    <p>If the current character is a closing bracket character of any kind, the current character <em>should</em> be the matching closing bracket for whichever type of opening bracket is at the top of the stack. This is to say, <em>a legal closing bracket character must close the <strong>most recent bracket which is currently open</strong></em>.</p>

    <ul>
      <li>
        <p>If this is true, pop the opening bracket from the top of the stack and move on to the next character.</p>
      </li>
      <li>
        <p>If this is false, the current character is illegal and the line is <strong>corrupted.</strong> In this case the function <code class="language-plaintext highlighter-rouge">completion_string</code> returns <code class="language-plaintext highlighter-rouge">False</code>. Any further characters in the line are irrelevant.</p>
      </li>
    </ul>
  </li>
</ul>

<p>If the parser reaches the end of the string, the line must be <strong>incomplete</strong>, since the puzzle states that none of the lines of the input are correct.</p>

<p>How do we get the <strong>completion string</strong> which we want to return? Well, our stack still contains all the opening bracket characters which have yet to be closed. All we need to do is reverse the stack, map each character onto the matching closing character, and there’s your completion string. Ready for scoring!</p>

<p>To get a final solution we just need to score every completion string and find the median score.</p>

<h3 id="python-code-3">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">median</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>


<span class="n">bracketmap</span> <span class="o">=</span> <span class="p">{</span><span class="s">')'</span><span class="p">:</span><span class="s">'('</span><span class="p">,</span> <span class="s">']'</span><span class="p">:</span> <span class="s">'['</span><span class="p">,</span> <span class="s">'}'</span><span class="p">:</span> <span class="s">'{'</span><span class="p">,</span><span class="s">'&gt;'</span><span class="p">:</span><span class="s">'&lt;'</span><span class="p">}</span>

<span class="n">invbracketmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">bracketmap</span><span class="p">.</span><span class="n">items</span><span class="p">()}</span>

<span class="n">openers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bracketmap</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">completion_string</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">openers</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bracketmap</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
    
    <span class="n">stack</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">invbracketmap</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">stack</span>

<span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">scoremap</span> <span class="o">=</span> <span class="p">{</span><span class="s">')'</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">']'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">'}'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s">'&gt;'</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span> <span class="n">scoremap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">score</span>

<span class="k">def</span> <span class="nf">solve_part_two</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">score</span><span class="p">(</span><span class="n">completion_string</span><span class="p">(</span><span class="n">line</span><span class="p">))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="n">completion_string</span><span class="p">(</span><span class="n">line</span><span class="p">)]</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">median</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>


<span class="k">print</span><span class="p">(</span><span class="n">solve_part_two</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre></div></div>

  </div><a class="u-url" href="/2022/01/05/advent-of-code-2021-days-6-10.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Dave Bartram Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Dave Bartram Blog</li><li><a class="u-email" href="mailto:david.bartram@gmail.com">david.bartram@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/davidbartram"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">davidbartram</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Lessons I&#39;m learning as a: Software platform engineer, Tabletop roleplayer, Lifelong lover of maths &amp; science</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
