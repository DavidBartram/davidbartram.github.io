<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Advent Of Code 2021 Days 21-25 | Dave Bartram Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Advent Of Code 2021 Days 21-25" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Advent of Code 2021 - Days 21-25" />
<meta property="og:description" content="Advent of Code 2021 - Days 21-25" />
<link rel="canonical" href="http://localhost:4000/2022/04/17/advent-of-code-2021-days-21-25.html" />
<meta property="og:url" content="http://localhost:4000/2022/04/17/advent-of-code-2021-days-21-25.html" />
<meta property="og:site_name" content="Dave Bartram Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-17T14:45:39+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Advent Of Code 2021 Days 21-25" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-17T14:45:39+01:00","datePublished":"2022-04-17T14:45:39+01:00","description":"Advent of Code 2021 - Days 21-25","headline":"Advent Of Code 2021 Days 21-25","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/04/17/advent-of-code-2021-days-21-25.html"},"url":"http://localhost:4000/2022/04/17/advent-of-code-2021-days-21-25.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Dave Bartram Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dave Bartram Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Advent Of Code 2021 Days 21-25</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-04-17T14:45:39+01:00" itemprop="datePublished">Apr 17, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="advent-of-code-2021---days-21-25">Advent of Code 2021 - Days 21-25</h1>

<p><img src="/images/pexels-photo-6211095.jpeg" alt="christmas tree decorated with baubles and garland" /></p>

<p>Welcome to the final instalment of my series on Advent of Code 2021! Christmas is but a faded memory now, indeed it is literally Easter Sunday 2022 as I type. But I’m still here to spread one last dose of festive Python joy. All code on Github <a href="https://git.io/JmAvJ">here</a>. The code below is for Part 2 of each day, which often incorporates Part 1 in some way.</p>

<p>I hope you’ve enjoyed joining me on this journey through AoC 2021, I’ve learned a lot, I hope you’ve picked up one or two things as well. Merry Christmas and Happy Easter to all!</p>

<h2 id="day-21---dirac-dice">Day 21 - <a href="https://adventofcode.com/2021/day/16">Dirac Dice</a></h2>

<h3 id="thoughts">Thoughts</h3>

<p>As a former student of quantum mechanics, the name and concept of this puzzle appealed to me. Paul Dirac was one of the founding physicists in quantum mechanics, inventing many of the concepts and notations still used in quantum physics (and quantum computing) today.</p>

<p>As far as Part 2 of the puzzle is concerned, a Dirac die is a 3-sided die with sides labelled 1, 2 and 3.</p>

<p>We take our Dirac die and play a game against the computer of Santa’s submarine. The game consists of a circular track of ten spaces labelled 1 through 10 clockwise. The starting position of each player is given by the puzzle input, and each player starts with a score of 0.</p>

<p>To take a turn, roll the Dirac die three times and add up the results. Move that many spaces clockwise on the circular path. Add the number of the space you land on to your score. If your score is 21 or better, you have won! Otherwise, your opponent takes a turn.</p>

<p>Unfortunately, Dirac dice are imbued with powers inspired by the Many Worlds interpretation of quantum mechanics. Every time you roll a Dirac die, the universe splits into three worlds, one where the die rolled each possible outcome. In taking a single turn, a player rolls the Dirac die three times, creating 27 universes!</p>

<p>“All” we have to do is determine whether Player 1 or Player 2 wins in more universes, and the puzzle answer is the number of universes in which that player wins. What could be simpler?</p>

<h4 id="dice-result-frequencies">Dice Result Frequencies</h4>

<p>The first thing I wanted to do was count a few universes at a time. When three Dirac dice are thrown and added up, there are 27 possible universes. But many of those universes share the same value for the sum of the dice, and are thus indistinguishable in terms of the game rules.</p>

<p>There’s only 1 universe in which you roll a 3. You must have rolled {1,1,1}.</p>

<p>There are 3 universes in which you get a total of 4, depending on which die rolls a 2. You might roll {2,1,1}, {1,2,1} or {1,1,2}.</p>

<p>And so on. My code calculates these values directly to produce a dictionary from total score to number of universes called <code class="language-plaintext highlighter-rouge">dice_freq</code>, but this doesn’t depend on the input and will always be as follows:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
</span><span class="mi">5</span><span class="err">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
</span><span class="mi">6</span><span class="err">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">
</span><span class="mi">7</span><span class="err">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
</span><span class="mi">8</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
</span><span class="mi">9</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="recursive-function-for-playing-dirac-dice">Recursive Function for Playing Dirac Dice</h4>

<p>Before a turn is taken, the game state can be defined by 5 parameters. The position and score for each player, and whose turn is next. The game of Dirac dice has no “memory”. If the game state is the same, it doesn’t matter if it is reached on turn 2 or turn 200.</p>

<p>To play Dirac dice recursively, the solution below does the following via a function <code class="language-plaintext highlighter-rouge">play_dirac_dice</code>:</p>

<ul>
  <li>Check if either player won at the end of the last turn. I count victory for player 1 with a weight of 1, and victory for player 2 with a weight of 0.</li>
  <li>If the game is not over, we need to deal with subgames - all the further turns that happen in various universes branching off the current state.</li>
  <li>Track the total number of victories for player 1 in a variable called <code class="language-plaintext highlighter-rouge">subgame_total</code>, which is initialised at 0.</li>
  <li>Iterate over all the possible scores on the dice (the keys of <code class="language-plaintext highlighter-rouge">dice_freq</code>).
    <ul>
      <li>Increase <code class="language-plaintext highlighter-rouge">subgame_total</code> by the frequency of that score (<code class="language-plaintext highlighter-rouge">dice_freq[score]</code>) multiplied by the output of <code class="language-plaintext highlighter-rouge">play_dirac_dice</code>, passing in the state of the game as it would be if that score had just been rolled by the active player.</li>
    </ul>
  </li>
  <li>Recursive function calls will continue until either player 1 wins (returning 1 back up the chain of recursion) or player 0 wins (returning 0).</li>
  <li><code class="language-plaintext highlighter-rouge">subgame_total</code> will thus accumulate the total number of universes in which player 1 is victorious, given the starting state passed in to <code class="language-plaintext highlighter-rouge">play_dirac_dice</code> at the beginning.</li>
  <li>Return <code class="language-plaintext highlighter-rouge">subgame_total</code>.</li>
</ul>

<p>This function calculates the number of universes in which player 1 wins. We also need to calculate the number of universes in which player 2 wins, which is achieved by passing a different initial game state to the function. In essence, to find out when player 2 wins, initialise the game state such that player 1 and player 2 have swapped labels. Their initial position swaps, and the first turn goes to the newly-labelled “player 2”, who was originally player 1.</p>

<h4 id="caching">Caching</h4>

<p>The numbers of universes involved here are combinatorically huge - there are around a quadrillion possible universes in total, give or take.</p>

<p>Yes, we’ve added slight efficiency by calculating the frequency of different dice results in advance, but we haven’t made serious strides in cutting down the universe count. This kind of recursion could easily take an unholy amount to time to run.</p>

<p>The key thing to realise here, is that while the number of possible universes is vast, the number of possible game states is relatively small. Each player can be in one of 10 positions on the board, have a score from 0 to 30 (a score of 30 happens if your score is 20, just below the threshold to win, then you land on a 10 and win). The next player to take a turn is either player 1 or player 2.</p>

<p>The number of possible game states is 10 x 10 x 31 x 31 x 2 = 192,200. And not all of those states are necessarily accessible from a given starting state.</p>

<p>As a result, we can see that we will be calling <code class="language-plaintext highlighter-rouge">play_dirac_dice</code> many times with the same input. This is exactly what caching was made for. Every time we call <code class="language-plaintext highlighter-rouge">play_dirac_dice</code> with an input we’ve seen before, we should return the previous output rather than running the function again.</p>

<p>You can implement this caching (or “memoization”) yourself with a dictionary from input to output, but in this case I used the built-in Python LRU cache decorator.</p>

<h3 id="python-code">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="c1">#calculate the frequency of each possible sum of 3 rolls of a 3-sided die with sides labelled 1, 2 and 3
</span><span class="n">dice_results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

<span class="n">dice_results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">dice_results</span><span class="p">]</span>

<span class="n">dice_freq</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">dice_results</span><span class="p">))</span>

<span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span> <span class="c1">#caching
</span><span class="k">def</span> <span class="nf">play_dirac_dice</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">score1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">score2</span><span class="p">,</span> <span class="n">whoseTurn</span><span class="p">):</span>
    <span class="c1">#given the position and score of each player, and a marker for whose turn is next
</span>    <span class="c1">#return the number of universes arising from this game state in which player 1 wins
</span>
    <span class="c1">#print(pos1, score1, pos2, score2, whoseTurn)
</span>
    <span class="k">if</span> <span class="n">score1</span><span class="o">&gt;=</span><span class="mi">21</span><span class="p">:</span> <span class="c1">#player 1 wins
</span>        <span class="k">return</span> <span class="mi">1</span>
    
    <span class="k">elif</span> <span class="n">score2</span><span class="o">&gt;=</span><span class="mi">21</span><span class="p">:</span> <span class="c1">#player 2 wins
</span>        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">subgame_total</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">whoseTurn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#player 1 takes a turn next
</span>        <span class="k">for</span> <span class="n">dice</span> <span class="ow">in</span> <span class="n">dice_freq</span><span class="p">:</span>
            <span class="n">newpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos1</span><span class="o">+</span><span class="n">dice</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">#update player 1's position
</span>
            <span class="c1">#recursively call the function for the updated game state
</span>            <span class="c1">#multiply by dice_freq[dice] because each total on the dice has a different frequency
</span>            <span class="c1">#e.g. there are 3 universes in which dice==3 but 7 universes in which dice==6
</span>            <span class="n">subgame_total</span> <span class="o">+=</span> <span class="n">dice_freq</span><span class="p">[</span><span class="n">dice</span><span class="p">]</span><span class="o">*</span><span class="n">play_dirac_dice</span><span class="p">(</span><span class="n">newpos</span><span class="p">,</span><span class="n">score1</span><span class="o">+</span><span class="n">newpos</span><span class="p">,</span><span class="n">pos2</span><span class="p">,</span><span class="n">score2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1">#player 2 takes a turn next
</span>        <span class="k">for</span> <span class="n">dice</span> <span class="ow">in</span> <span class="n">dice_freq</span><span class="p">:</span>
            <span class="n">newpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos2</span><span class="o">+</span><span class="n">dice</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">#update player 1's position
</span>
            <span class="c1">#as above, recursively call the function for the updated game state
</span>            <span class="n">subgame_total</span> <span class="o">+=</span> <span class="n">dice_freq</span><span class="p">[</span><span class="n">dice</span><span class="p">]</span><span class="o">*</span><span class="n">play_dirac_dice</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span><span class="n">score1</span><span class="p">,</span><span class="n">newpos</span><span class="p">,</span><span class="n">score2</span><span class="o">+</span><span class="n">newpos</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subgame_total</span>

<span class="c1">#starting positions hard-coded from the input
</span><span class="n">start1</span> <span class="o">=</span> <span class="mi">7</span> 
<span class="n">start2</span> <span class="o">=</span> <span class="mi">5</span> 

<span class="n">wins</span> <span class="o">=</span> <span class="p">(</span><span class="n">play_dirac_dice</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">start2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">play_dirac_dice</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">start1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">wins</span><span class="p">))</span>
</code></pre></div></div>
<p>Day 22 - <a href="https://adventofcode.com/2021/day/22">Reactor Reboot</a>
—————————————————————</p>

<h3 id="thoughts-1">Thoughts</h3>

<p>After a lot of initial frustration, this problem really caught my imagination and I solved it a few slightly different ways. I’m going to describe the method that I implemented last. It’s probably the best…or at least the one I remember most clearly…</p>

<h4 id="the-problem">The problem</h4>

<p>Consider a 3D grid made up of cubes. Each cube sits at an integer 3D coordinate <code class="language-plaintext highlighter-rouge">(x,y,z)</code>. A cube can either be <strong>on</strong> or <strong>off</strong>. Initially, every cube in the grid is off.</p>

<p>The goal is to apply a set of instructions to this grid.</p>

<p>Each instruction consists of a <strong>cuboid</strong>, and the instruction to set the state of all the cubes inside that cuboid to either <strong>on</strong> or <strong>off</strong>. Each cuboid is defined by contiguous intervals of each coordinate. The end points of the intervals are all integers, and they are inclusive. So for example a cuboid might include all cubes whose coordinates <code class="language-plaintext highlighter-rouge">(x,y,z)</code> satisfy <code class="language-plaintext highlighter-rouge">-5 &lt;= x &lt;= 10, 300 &lt;= y &lt;= 350</code> and <code class="language-plaintext highlighter-rouge">45 &lt;= z &lt;= 51</code></p>

<p>In my solution, each cuboid is defined by three <strong>closed interval</strong> objects from the <a href="https://github.com/kvesteri/intervals">intervals</a> library.</p>

<p>The goal is to execute approximately 400 of these instructions, some with coordinate boundaries in the tens of thousands. A method based on tracking the state of individual cubes is doomed to failure by the scale of the problem.</p>

<h4 id="approach">Approach</h4>

<p>First let’s decide how to represent the instructions we want to apply.</p>

<p>Each element in the list <code class="language-plaintext highlighter-rouge">instructions</code> is a tuple <code class="language-plaintext highlighter-rouge">(op, (ix, iy, iz))</code> where op is the operation (either ‘on’ or ‘off’), and the other element is a <code class="language-plaintext highlighter-rouge">cuboid</code> object, a tuple of <a href="https://github.com/kvesteri/intervals">interval</a> objects defining a cuboid.</p>

<p>The key concept in applying these instructions, is that whenever a new cuboid is switched either on or off, we have to tread carefully if the new cuboid <em>overlaps</em> with any previous cuboids.</p>

<p>We begin with all the cubes in the off state. Let’s say we apply an <strong>on</strong> cuboid, called Cuboid A. Now we have a nice neat cuboid of <strong>on</strong> cubes. The number of cubes switched on is just the volume of Cuboid A.</p>

<p>If we apply a second <strong>on</strong> cuboid, what’s the number of cubes switched on? We could try adding the volume of Cuboid A to Cuboid B - and that’s the right answer if the cuboids don’t overlap. If they do overlap, we’ll count some of the cubes twice. To correct that, we can add the volume of cuboid A to the volume of cuboid B, and subtract the volume of the intersection.</p>

<p>This is an application of the <a href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">inclusion-exclusion principle</a>, which in its guise as the “addition rule” is popular with probability students everywhere.</p>

<p>To handle this, my solution includes a defaultdict <code class="language-plaintext highlighter-rouge">cuboids</code> from cuboids to signs. The sign of a cuboid is either 1, -1 or 0. 0 is the default value. When we calculate the total number of on cuboids at the end of the solution, we will simply sum the volume of each cuboid multiplied by its sign.</p>

<p>The key is keeping the sign correct. For the case of two intersecting <strong>‘on’</strong> cuboids, this is simple. The two cuboids should have sign +1, and their cuboid of intersection should have sign -1.</p>

<p>Note that at this point we would have applied only <em>two</em> instructions but our <code class="language-plaintext highlighter-rouge">cuboids</code> dictionary will contain <em>three</em> cuboids and their respective signs. As more instructions are applied, <code class="language-plaintext highlighter-rouge">cuboids</code> will contain original cuboids from the instruction list, cuboids of intersection between them, cuboids of intersection between cuboids of intersection and new cuboids, and so on. It’s dizzying to imagine but the mathematics will bestow upon every cuboid its proper sign, and keep them all in place. Since <code class="language-plaintext highlighter-rouge">cuboids</code> is a dictionary, it will also keep track only of unique cuboids. From time to time a new cuboid, or cuboid of intersection, will exactly overlap with a previous one. Again, we trust to mathematics to correctly handle this, my visualisation skills are not up to the task of imagining the process!</p>

<h4 id="applying-a-single-instruction">Applying a Single Instruction</h4>

<p>So how does this mathematics work? How do we apply an arbitrary instruction?</p>

<p>Let’s call it instruction X, consisting of operation X (either ‘off’ or ‘on’) and cuboid X.</p>

<p>First, create a copy of the current cuboids dictionary and call it <code class="language-plaintext highlighter-rouge">new</code>.</p>

<p>If operation X is ‘on’, we need to add cuboid x to the <code class="language-plaintext highlighter-rouge">new</code> dictionary as a key with a value of 1. This is intuitive, we ultimately want to count the total number of ‘on’ cubes, so we want to count this cuboid as a positive.</p>

<p>If operation X is ‘off’, we do not add it to the <code class="language-plaintext highlighter-rouge">new</code> dictionary at all. We’re not counting the ‘off’ cuboids, so we don’t need this. We definitely care if cuboid X is ‘off’ and overlaps with an ‘on’ cuboid, turning some previously ‘on’ cubes to the ‘off’ state, but that’s handled below. For now, do nothing.</p>

<p>Regardless of operation X, we now iterate over the current <code class="language-plaintext highlighter-rouge">cuboids</code> dictionary (not the <code class="language-plaintext highlighter-rouge">new</code> dictionary).</p>

<p>We calculate the cuboid of intersection between each cuboid in the dictionary, and cuboid X, our brand new cuboid. If the cuboid of intersection exists, we add it to <code class="language-plaintext highlighter-rouge">new</code> with the appropriate sign, based on its current sign in the new dictionary and the sign of its ‘parent’ cuboid (the cuboid that was intersected with cuboid X to produce it).</p>

<p>“The appropriate sign” is the part of the procedure that is frankly magical.</p>

<p><strong>The sign of the cuboid of intersection (if it exists), is equal to its current value in the <code class="language-plaintext highlighter-rouge">new</code> dictionary, minus the value of its ‘parent’ cuboid in the <code class="language-plaintext highlighter-rouge">cuboids</code> dictionary.</strong></p>

<p>Once we have followed this procedure for every cuboid in <code class="language-plaintext highlighter-rouge">cuboids</code>, we return <code class="language-plaintext highlighter-rouge">new</code>. This has successfully applied the instruction.</p>

<h4 id="wait-what">Wait, what???</h4>

<p>That’s it. No handling of edge cases is required. You might be worried that the new cuboid could be a duplicate of a previous cuboid - that’s fine. Or that some of these many, many cuboids of intersection will also be duplicates of each other, or duplicates of previous cuboids - that’s also fine. As long as each unique cuboid is in the dictionary with a correct sign, I don’t care where it came from. And the procedure above keeps the signs correct regardless of the scenario.</p>

<p><strong>The sign of the cuboid of intersection (if it exists), is equal to its current value in the <code class="language-plaintext highlighter-rouge">new</code> dictionary, minus the value of its ‘parent’ cuboid in the <code class="language-plaintext highlighter-rouge">cuboids</code> dictionary.</strong></p>

<p>Let’s consider the simple case of two ‘on’ instructions, A and B. Assume that cuboid A intersects with cuboid B, but they are not identical.</p>

<p>Both <code class="language-plaintext highlighter-rouge">cuboids</code> and <code class="language-plaintext highlighter-rouge">new</code> are empty, but remember these are defaultdicts, and will return 0 if the value for any key is requested.</p>

<h5 id="instruction-a-an-on-cuboid">Instruction A (an ‘on’ cuboid)</h5>

<p>To apply instruction A, we add cuboid A to the new dictionary with value 1. We then iterate over <code class="language-plaintext highlighter-rouge">cuboids</code>, which is empty, so we do nothing. Then we return <code class="language-plaintext highlighter-rouge">new</code>, and set <code class="language-plaintext highlighter-rouge">cuboids = new</code>.</p>

<p>At this point, <code class="language-plaintext highlighter-rouge">cuboids == { cuboid A : 1}</code>.</p>

<p>If we calculated the volume of ‘on’ cuboids now, we would just get the volume of cuboid A. Quite right.</p>

<h5 id="instruction-b-another-on-cuboid">Instruction B (another ‘on’ cuboid)</h5>

<p>Now apply instruction B. Make a copy of <code class="language-plaintext highlighter-rouge">cuboids</code> and call it <code class="language-plaintext highlighter-rouge">new</code>. Since instruction B is also an ‘on’ instruction, we will add cuboid B to <code class="language-plaintext highlighter-rouge">new</code> with a value of 1.</p>

<p>Now iterate over cuboids, which currently only contains cuboid A. We calculate the intersection between cuboids A and B, and give it a sign. The sign should be its current value in the new dictionary (which is 0, because this cuboid hasn’t been put into new yet), minus the value of cuboid A in the cuboids dictionary (which is 1).</p>

<p>Therefore, the cuboid of intersection is added to new with the sign 0 - 1 = -1.</p>

<p>Then we return <code class="language-plaintext highlighter-rouge">new</code>, and set <code class="language-plaintext highlighter-rouge">cuboids = new</code>.</p>

<p>At this point, <code class="language-plaintext highlighter-rouge">cuboids == { cuboid A : 1, cuboid B : 1, intersection(A,B)</code> : -1<code class="language-plaintext highlighter-rouge">}</code> If we calculated the number of ‘on’ cubes now, we would simply be applying the inclusion-exclusion principle, which would surely give the correct result!</p>

<h5 id="instruction-c-an-off-cuboid">Instruction C (an ‘off’ cuboid)</h5>

<p>Now let’s apply instruction C, which is an ‘off’ cuboid. Let’s assume it overlaps with cuboid A, cuboid B and cuboid C but is not identical to any of them.</p>

<p>Make a copy of <code class="language-plaintext highlighter-rouge">cuboids</code> and call it <code class="language-plaintext highlighter-rouge">new</code>. We don’t need to add cuboid C to new, as it is an ‘off’ cuboid.</p>

<p>Iterate over <code class="language-plaintext highlighter-rouge">cuboids</code>, which contains cuboid A, cuboid B and intersection(A,B).</p>

<p>cuboid A will produce intersection(A,C) with sign 0 - 1 = -1.</p>

<p>cuboid B will produce intersection(B,C) with sign 0 - 1 = -1.</p>

<p>intersection(A,B) will produce intersection(A,B,C) with sign 0 - (-1) = 1.</p>

<p>Then we return <code class="language-plaintext highlighter-rouge">new</code>, and set <code class="language-plaintext highlighter-rouge">cuboids = new</code>.</p>

<p>At this point, <code class="language-plaintext highlighter-rouge">cuboids == { cuboid A : 1, cuboid B : 1, intersection(A,B)</code> : -1, intersection(A,C) : -1, <code class="language-plaintext highlighter-rouge">intersection(B,C)</code> : -1, <code class="language-plaintext highlighter-rouge">intersection(A,B,C)</code> : 1<code class="language-plaintext highlighter-rouge">}</code>.</p>

<p>Does this make sense? Well, yes! We add the volumes of cuboid A and cuboid B, which double counts intersection(A,B). Subtracting intersection(A,B) corrects that.</p>

<p>But then cuboid C comes along and turns off all the previously-on cubes in intersection(A,C) and intersection(B,C), so we subtract those volumes.</p>

<p>But we’ve overcounted here as well! We’ve subtracted too much, because intersection(A,C) and intersection(B,C) intersect! We’ve double counted intersection(A,B,C), but we’ve overcounted while subtracting. The appropriate correction is to <em>add</em> the volume of intersection(A,B,C) back into our total. Which, indeed, is why intersection(A,B,C) has a sign of 1.</p>

<p>This example doesn’t cover every possibility, but it hopefully illustrates how the solution correctly handles ‘on’ and ‘off’ instructions, while dealing with intersections correctly.</p>

<h3 id="python-code-1">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">intervals</span> <span class="k">as</span> <span class="n">I</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">median</span>

<span class="k">def</span> <span class="nf">initialise</span><span class="p">():</span>
    <span class="c1">#read the input file
</span>    <span class="c1">#output instructions, a list of tuples (op, (ix,iy,iz))
</span>    <span class="c1">#op is either 'on' or 'off', representing the operation for that instruction
</span>    <span class="c1">#ix, iy, iz are intervals defining the cuboid for that instruction
</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s">'-{0,1}\d{1,10}'</span><span class="p">,</span> <span class="n">ranges</span><span class="p">)]</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">closed</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">closed</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">closed</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">op</span><span class="p">,(</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">,</span><span class="n">iz</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">instructions</span>

<span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">cuboid</span><span class="p">):</span>
    <span class="c1">#calculate the number of cubes contained in a cuboid
</span>    <span class="c1">#cubes on the boundary of a cuboid count as contained within that cuboid
</span>
    <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span> <span class="o">=</span> <span class="n">cuboid</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">ix</span><span class="p">.</span><span class="n">upper</span> <span class="o">-</span> <span class="n">ix</span><span class="p">.</span><span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">iy</span><span class="p">.</span><span class="n">upper</span> <span class="o">-</span> <span class="n">iy</span><span class="p">.</span><span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">iz</span><span class="p">.</span><span class="n">upper</span> <span class="o">-</span> <span class="n">iz</span><span class="p">.</span><span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span>


<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">cuboid1</span><span class="p">,</span><span class="n">cuboid2</span><span class="p">):</span>
    <span class="c1">#calculate the cuboid of intersection between two cuboids
</span>    <span class="c1">#return the cuboid of intersection, or False if the input cuboids do not intersect
</span>
    <span class="n">ix1</span><span class="p">,</span><span class="n">iy1</span><span class="p">,</span><span class="n">iz1</span> <span class="o">=</span> <span class="n">cuboid1</span>
    <span class="n">ix2</span><span class="p">,</span> <span class="n">iy2</span><span class="p">,</span> <span class="n">iz2</span> <span class="o">=</span> <span class="n">cuboid2</span>

    <span class="n">ix</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">&amp;</span> <span class="n">ix2</span> <span class="c1">#interval intersection
</span>    <span class="n">iy</span> <span class="o">=</span> <span class="n">iy1</span> <span class="o">&amp;</span> <span class="n">iy2</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="n">iz1</span> <span class="o">&amp;</span> <span class="n">iz2</span>

    <span class="k">if</span> <span class="n">ix</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="ow">or</span> <span class="n">iy</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="ow">or</span> <span class="n">iz</span><span class="p">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">,</span><span class="n">iz</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">apply_one_instruction</span><span class="p">(</span><span class="n">cuboids</span><span class="p">,</span><span class="n">newcuboid</span><span class="p">,</span> <span class="n">onoff</span><span class="p">):</span>
    <span class="c1">#apply a single instruction
</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">cuboids</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">onoff</span> <span class="o">==</span> <span class="s">'on'</span><span class="p">:</span>
        <span class="n">new</span><span class="p">[</span><span class="n">newcuboid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">cuboid</span><span class="p">,</span> <span class="n">sign</span> <span class="ow">in</span> <span class="n">cuboids</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">newcuboid</span><span class="p">,</span><span class="n">cuboid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="n">new</span><span class="p">[</span><span class="n">overlap</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sign</span>

    <span class="k">return</span> <span class="n">new</span>

<span class="k">def</span> <span class="nf">apply_instructions</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="c1">#apply all the instructions in the input file
</span>    <span class="c1">#return the total number of 'on' cubes after all instructions are applied
</span>    <span class="n">cuboids</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="n">onoff</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newcuboid</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cuboids</span> <span class="o">=</span> <span class="n">apply_one_instruction</span><span class="p">(</span><span class="n">cuboids</span><span class="p">,</span><span class="n">newcuboid</span><span class="p">,</span><span class="n">onoff</span><span class="p">)</span>
    
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">cuboid</span><span class="p">,</span> <span class="n">sign</span> <span class="ow">in</span> <span class="n">cuboids</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">sign</span><span class="o">*</span><span class="n">volume</span><span class="p">(</span><span class="n">cuboid</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">total</span>

<span class="n">instructions</span> <span class="o">=</span> <span class="n">initialise</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">apply_instructions</span><span class="p">(</span><span class="n">instructions</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="day-23---amphipod">Day 23 - <a href="https://adventofcode.com/2021/day/23">Amphipod</a></h2>

<h3 id="thoughts-2">Thoughts</h3>

<p>This puzzle was complex to implement but the concept is simple. Four types of amphipod (types A, B, C and D) consist in a burrow consisting of four rooms and one hallway. Each room can hold four amphipods in single file.</p>

<p>There are four of each type of amphipod. The amphipods start disorganised (their starting arrangement is based on your individual puzzle input), and the goal is to move them so that the type A amphipods are in the leftmost room, the type B’s are one room to the right of the type A’s, and so on.</p>

<p>The amphipods can move around the burrow, obeying certain rules.</p>

<ul>
  <li>Amphipods cannot pass through each other.</li>
  <li>Moving an amphipod one space has a cost of 1 energy for a type A, 10 energy for a type B, 100 energy for a type C, and 1000 energy for a type D.</li>
  <li>Amphipods cannot stop on the space directly outside any room. They can only move into that space if they immediately continue moving.</li>
  <li>Amphipods cannot move from the hallway into a room unless that room is their destination <strong>and</strong> the room currently contains no amphipods of a different type.</li>
</ul>

<p>The goal is to find the minimum total energy cost to arrange the amphipods correctly.</p>

<h4 id="my-approach">My Approach</h4>

<p>My approach here was to use Dijkstra’s algorithm, implemented with a Python <a href="https://www.geeksforgeeks.org/priority-queue-in-python/">Priority Queue</a>.</p>

<p>Since the energy cost for the different types of amphipod are powers of 10, it is easier to think of the amphipod types as 0, 1, 2, 3 rather than A,B,C,D. Then the rooms can be labelled the same way, so that the type 0 amphipods are aiming to get into room 0, and so on. The type of an amphipod is usually denoted by the variable <code class="language-plaintext highlighter-rouge">amphi</code>.</p>

<p>The room number under consideration is denoted by the variable <code class="language-plaintext highlighter-rouge">r</code>.</p>

<p>To map out the burrow, I labelled the seven hallway positions 0 to 6 from left to right. In the code, the hallway position is denoted by the variable <code class="language-plaintext highlighter-rouge">h.</code></p>

<p>Positions inside a room are denoted by the variable <code class="language-plaintext highlighter-rouge">r_pos</code>, where <code class="language-plaintext highlighter-rouge">r_pos</code>=0 is the space next to the hallway and <code class="language-plaintext highlighter-rouge">r_pos</code> increases as you go deeper into the room, to a maximum of <code class="language-plaintext highlighter-rouge">r_pos</code>=4.</p>

<p>The dictionary <code class="language-plaintext highlighter-rouge">distance</code> from tuples <code class="language-plaintext highlighter-rouge">(h,r)</code> to integer distances is hard-coded with the number of spaces required to move from hallway position <code class="language-plaintext highlighter-rouge">h</code> to room position 0 inside room <code class="language-plaintext highlighter-rouge">r</code>.</p>

<p><code class="language-plaintext highlighter-rouge">distance[(3,1)] == 2</code> means that an amphipod needs to move two spaces to get from hallway position 3 to position 0 inside room 1.</p>

<p>A state of the game board is represented by two tuples, <code class="language-plaintext highlighter-rouge">hall</code> and <code class="language-plaintext highlighter-rouge">rooms</code>.</p>

<p>For example, my initial state looks like this:</p>

<p><code class="language-plaintext highlighter-rouge">hall = (None,None,None,None,None,None,None)</code></p>

<p><code class="language-plaintext highlighter-rouge">rooms = ((3,3,3,3),(2,2,1,2),(0,1,0,1),(1,0,2,0))</code></p>

<p>This means that all seven positions in the hallway are unoccupied. Room 0 contains four amphipods of type 3, and so on up to room 3, which contains two type 0 amphipods, a type 2 and a type 1. The type 1 amphipod in room 3 is directly adjacent to the hallway, with the other three in single file behind it.</p>

<p>Let’s say we moved the type 1 amphipod in room 3 out into hallway position 6. This is a legal move and would result in the following board state:</p>

<p><code class="language-plaintext highlighter-rouge">hall = (None,None,None,None,None,None,1)</code></p>

<p><code class="language-plaintext highlighter-rouge">rooms = ((3,3,3,3),(2,2,1,2),(0,1,0,1),(None,0,2,0))</code></p>

<p>The goal is to find the minimum energy cost to achieve the desired final state, which looks like this:</p>

<p><code class="language-plaintext highlighter-rouge">hall = (None,None,None,None,None,None,None)</code></p>

<p><code class="language-plaintext highlighter-rouge">rooms = ((0,0,0,0),(1,1,1,1),(2,2,2,2),(3,3,3,3))</code></p>

<p>The implementation below is a little finicky in the details, and not particularly fast, but it does the job!</p>

<h3 id="python-code-2">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">inf</span><span class="p">,</span> <span class="n">ceil</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="c1">#distance (h,r) = distance from hallway position h to front of room r or vice-versa
</span><span class="n">distance</span> <span class="o">=</span><span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">3</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">5</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">7</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">9</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">6</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">8</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">6</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">4</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">6</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">8</span><span class="p">,(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">6</span><span class="p">,(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">9</span><span class="p">,(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">7</span><span class="p">,(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">5</span><span class="p">,(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span><span class="mi">3</span>
    <span class="p">}</span>

<span class="k">def</span> <span class="nf">move_cost</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">amphi</span><span class="p">,</span><span class="n">r_pos</span><span class="p">):</span>
    <span class="c1">#calculate the energy cost to move an amphipod
</span>    <span class="c1">#from hallway position h to room position r_pos inside room r
</span>    <span class="c1">#or vice-versa
</span>    <span class="n">cost</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_pos</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">amphi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost</span>

<span class="k">def</span> <span class="nf">hall_to_room</span><span class="p">(</span><span class="n">amphi</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">):</span>
    <span class="c1">#given an amphipod of type amphi in hallway position h
</span>    <span class="c1">#with the current hall and room occupations given by hall and rooms
</span>    <span class="c1">#return None if the amphipod cannot be moved to its destination room
</span>    <span class="c1">#otherwise, return (newhall, newrooms, cost) representing the new hall and room occupations
</span>    <span class="c1">#and the cost of moving that amphipod to its destination room
</span>

    <span class="n">room_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mf">4.5</span><span class="p">}</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">room_index</span><span class="p">[</span><span class="n">amphi</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

    <span class="n">newhall</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hall</span><span class="p">)</span>
    <span class="n">newrooms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">room</span><span class="p">)</span> <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">]</span>

    <span class="c1">#check if there are any amphipods between this amphipod and its destination room
</span>    <span class="k">if</span> <span class="n">h</span><span class="o">&lt;</span><span class="n">j</span><span class="p">:</span>
        <span class="n">intervening_hall</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">!=</span><span class="bp">None</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">hall</span><span class="p">[</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">h</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
        <span class="n">intervening_hall</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">!=</span><span class="bp">None</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">hall</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">h</span><span class="p">]]</span>
    
    <span class="c1">#check if there are any amphipods of the wrong type in the destination room
</span>    <span class="n">wrong_amphi</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="o">!=</span><span class="n">amphi</span> <span class="ow">and</span> <span class="n">x</span><span class="o">!=</span><span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">[</span><span class="n">amphi</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">intervening_hall</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_amphi</span><span class="p">):</span>
        <span class="c1">#if the hallway is blocked or there are any wrong-type amphipods in the room
</span>        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">intervening_hall</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_amphi</span><span class="p">)):</span>
        <span class="c1">#calculate the position inside the destination room that the amphipod will move to
</span>        <span class="n">r_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rooms</span><span class="p">[</span><span class="n">amphi</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">==</span><span class="n">amphi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">[</span><span class="n">amphi</span><span class="p">]])</span>
        <span class="c1">#calculate the energy cost of the move
</span>        <span class="n">cost</span> <span class="o">=</span> <span class="n">move_cost</span><span class="p">(</span><span class="n">amphi</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">amphi</span><span class="p">,</span><span class="n">r_pos</span><span class="p">)</span>
        <span class="c1">#update the state of the hallway and rooms to account for the move
</span>        <span class="n">newhall</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">newrooms</span><span class="p">[</span><span class="n">amphi</span><span class="p">][</span><span class="n">r_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">amphi</span>
        <span class="n">newhall</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newhall</span><span class="p">)</span>
        <span class="n">newrooms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newroom</span><span class="p">)</span> <span class="k">for</span> <span class="n">newroom</span> <span class="ow">in</span> <span class="n">newrooms</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">newhall</span><span class="p">,</span> <span class="n">newrooms</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">room_to_hall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">amphi</span><span class="p">,</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">,</span> <span class="n">r_pos</span><span class="p">):</span>
    <span class="c1">#given an amphipod of type amphi in room r
</span>    <span class="c1">#with the current hall and room occupations given by hall and rooms
</span>    <span class="c1">#return None if the amphipod cannot be moved to hallway position h
</span>    <span class="c1">#otherwise, return (newhall, newrooms, cost) representing the new hall and room occupations
</span>    <span class="c1">#and the cost of moving that amphipod to hallway position h
</span>
    <span class="n">room_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mf">4.5</span><span class="p">}</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">room_index</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

    <span class="n">newhall</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hall</span><span class="p">)</span>
    <span class="n">newrooms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">room</span><span class="p">)</span> <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">]</span>

    <span class="c1">#check if there are any amphipods in the hallway between this amphipod and hallway position h
</span>    <span class="k">if</span> <span class="n">h</span><span class="o">&lt;</span><span class="n">j</span><span class="p">:</span>
        <span class="n">intervening_hall</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">!=</span><span class="bp">None</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">hall</span><span class="p">[</span><span class="n">h</span><span class="p">:</span><span class="n">k</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">h</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
        <span class="n">intervening_hall</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">!=</span><span class="bp">None</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">hall</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="c1">#check if there are any amphipods in the room between this amphipod and the hallway
</span>    <span class="k">if</span> <span class="n">r_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">intervening_room</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">r_pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">intervening_room</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">!=</span><span class="bp">None</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">r_pos</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">intervening_hall</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">intervening_room</span><span class="p">):</span>
        <span class="c1">#if there is an amphipod blocking this path
</span>        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">intervening_hall</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">intervening_room</span><span class="p">)):</span>
        <span class="c1">#calculate the cost of moving to hallway position h
</span>        <span class="n">cost</span> <span class="o">=</span> <span class="n">move_cost</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">amphi</span><span class="p">,</span><span class="n">r_pos</span><span class="p">)</span>
        <span class="c1">#update the state of the hallway and rooms to account for the move
</span>        <span class="n">newhall</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">amphi</span>
        <span class="n">newrooms</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">r_pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">newhall</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newhall</span><span class="p">)</span>
        <span class="n">newrooms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newroom</span><span class="p">)</span> <span class="k">for</span> <span class="n">newroom</span> <span class="ow">in</span> <span class="n">newrooms</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">newhall</span><span class="p">,</span> <span class="n">newrooms</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">neighbours</span><span class="p">(</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">):</span>
    <span class="c1">#find the legal board states one move away from the current board
</span>    <span class="c1">#helper function for Dijkstra
</span>    <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">h</span><span class="p">,</span><span class="n">amphi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hall</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">amphi</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">hall_to_room</span><span class="p">(</span><span class="n">amphi</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">neighbours</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">h</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hall</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span><span class="n">room</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r_pos</span><span class="p">,</span> <span class="n">amphi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">amphi</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">room_to_hall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">amphi</span><span class="p">,</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">,</span> <span class="n">r_pos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="c1">#print(result)
</span>                        <span class="n">neighbours</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">neighbours</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">visit</span><span class="p">,</span><span class="n">costs</span><span class="p">):</span>
    <span class="c1">#dijkstra's algorithm
</span>    
    <span class="k">while</span> <span class="ow">not</span> <span class="n">visit</span><span class="p">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">_</span><span class="p">,(</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">))</span> <span class="o">=</span> <span class="n">visit</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="c1">#get the next board state in the queue
</span>
        <span class="k">if</span> <span class="n">hall</span> <span class="o">==</span> <span class="n">final_hall</span> <span class="ow">and</span> <span class="n">rooms</span> <span class="o">==</span> <span class="n">final_rooms</span><span class="p">:</span>
            <span class="c1">#if the final state has been reached, return the cost
</span>            <span class="k">return</span> <span class="n">c</span>
        
        <span class="c1">#identify neighbouring board states
</span>        <span class="n">nbs</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">(</span><span class="n">hall</span><span class="p">,</span><span class="n">rooms</span><span class="p">)</span>

        <span class="c1">#dijkstra procedure
</span>        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbs</span><span class="p">:</span>
            <span class="c1">#update the cost with the cost of the move to that neighbour state
</span>            <span class="n">newc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">nb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">newc</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">[(</span><span class="n">nb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nb</span><span class="p">[</span><span class="mi">1</span><span class="p">])]:</span>
                <span class="c1">#update label if new cost is lower than current cost
</span>                <span class="n">costs</span><span class="p">[(</span><span class="n">nb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nb</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">newc</span>
                <span class="c1">#add the new board state to the queue
</span>                <span class="n">visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">newc</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">unique</span><span class="p">),(</span><span class="n">nb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nb</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>


<span class="c1">#starting board state - hard-coded from my puzzle input
</span><span class="n">start_hall</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
<span class="n">start_rooms</span> <span class="o">=</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="c1">#destination board state
</span><span class="n">final_hall</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
<span class="n">final_rooms</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="c1">#initialise variables for dijkstra
</span><span class="n">start_costs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">inf</span><span class="p">)</span> <span class="c1">#cost to reach all board states is initialised at infinity
</span><span class="n">start_costs</span><span class="p">[(</span><span class="n">start_hall</span><span class="p">,</span><span class="n">start_rooms</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#cost to reach initial board state is zero
</span><span class="n">unique</span><span class="o">=</span><span class="n">count</span><span class="p">()</span> <span class="c1">#a unique index for each board state, purely to break ties in the priority queue
</span>
<span class="n">visit</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span> <span class="c1">#priority queue of board states to visit
</span><span class="n">visit</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="nb">next</span><span class="p">(</span><span class="n">unique</span><span class="p">),(</span><span class="n">start_hall</span><span class="p">,</span><span class="n">start_rooms</span><span class="p">)))</span> <span class="c1">#initially, queue contains only the starting board state
</span>

<span class="k">print</span><span class="p">(</span><span class="n">dijkstra</span><span class="p">(</span><span class="n">visit</span><span class="p">,</span><span class="n">start_costs</span><span class="p">))</span> <span class="c1">#print puzzle answer
</span></code></pre></div></div>
<p>Day 24 - <a href="https://adventofcode.com/2021/day/24">Arithmetic Logic Unit</a>
———————————————————————-</p>

<h3 id="thoughts-3">Thoughts</h3>

<p>A very tricky puzzle that I eventually solved without any code at all. Here, the goal is to <em>understand</em> the input code, and then solve the puzzle from that understanding. It’s a code <em>reading</em> puzzle, not a code <em>writing</em> puzzle!</p>

<p>Santa’s submarine uses a program called MONAD to validate submarine model numbers. A model number is a 14-digit number. MONAD is a program which expects 14 sequential inputs. To validate a model number, enter the next digit of the model number into the program whenever an input is required. If and only if the model number is valid, MONAD will output a final value of zero for the variable <code class="language-plaintext highlighter-rouge">z.</code></p>

<p>The goal is to find the smallest (part 1) and largest (part 2) valid model numbers.</p>

<p>The processing unit that runs MONAD can store four integer variables:<code class="language-plaintext highlighter-rouge">w</code>,<code class="language-plaintext highlighter-rouge">x</code>,<code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code>. These variables all start with the value <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>MONAD contains instructions of 6 types.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inp a</code>- Read an input value and write it to variable <code class="language-plaintext highlighter-rouge">a</code>. As stated above, each time this type of instruction arises, we enter the next digit of the model number we are trying to verify.</li>
  <li><code class="language-plaintext highlighter-rouge">add a b</code>- Add the value of <code class="language-plaintext highlighter-rouge">a</code> to the value of <code class="language-plaintext highlighter-rouge">b</code>, then store the result in variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">mul a b</code> - Multiply the value of <code class="language-plaintext highlighter-rouge">a</code> by the value of <code class="language-plaintext highlighter-rouge">b</code>, then store the result in variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">div a b</code> - Divide the value of <code class="language-plaintext highlighter-rouge">a</code> by the value of <code class="language-plaintext highlighter-rouge">b</code>, truncate the result to an integer, then store the result in variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">mod a b</code> - Divide the value of <code class="language-plaintext highlighter-rouge">a</code> by the value of <code class="language-plaintext highlighter-rouge">b</code>, then store the <em>remainder</em> in variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">eql a b</code> - If the value of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are equal, then store the value <code class="language-plaintext highlighter-rouge">1</code> in variable <code class="language-plaintext highlighter-rouge">a</code>. Otherwise, store the value <code class="language-plaintext highlighter-rouge">0</code> in variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
</ul>

<p>To understand MONAD, we have to look at our puzzle input. For my input, it was clear that MONAD consists of 14 blocks of 18 lines. Each block takes in a single input. Each block falls into one of two categories, which I’ve called Type I and Type II.</p>

<p>There are seven Type I blocks and seven Type II blocks in the input.</p>

<h4 id="type-i-block">Type I Block</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inp w
mul x 0
add x z
mod x 26
div z 1
add x P
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y Q
mul y x
add z y
</code></pre></div></div>

<p>Here P and Q are constants which vary in different Type I blocks in the MONAD program. For example the first block in my input had P=13 and Q=13, whereas the third block had P=15 and Q=5. This is hard-coded into the program - P and Q are not variables in the processor, they are determined solely by the MONAD program.</p>

<p>Observing my input, I noticed the following are true for all Type I blocks:</p>

<ul>
  <li>9 &lt; P &lt; 17</li>
  <li>0 &lt; Q &lt; 17</li>
</ul>

<p>What does a Type I block do?</p>

<p>Well, if we look at lines 2 and 9, we see that x and y are zeroed before they are used. So any values of x and y currently stored in memory are ignored.</p>

<p>Lines 3, 4 and 6 will update the value of x such that x = zmod26 + P. Note that line 5 does nothing at all.</p>

<p>Line 7 checks whether w == z mod 26 + P. w is the latest input, which is a digit from the model number. Since P&gt;9 throughout MONAD, <strong>this equality will never hold</strong>.</p>

<p>z mod 26 + P will always be a two-digit number, and since w is a digit from the model number, they cannot be equal. As a result, every Type I block will write 0 to the variable x.</p>

<p>Therefore, when line 8 checks whether x == 0, this equality always holds. Therefore the program will write 1 to the variable x.</p>

<p>Lines 9-12 will always set y = 26, so line 13 will set z = 26*z.</p>

<p>Lines 14-17 will set y = w + Q.</p>

<p>Line 18 will set z = z + w + Q.</p>

<p>The overall effect of the block is to set <code class="language-plaintext highlighter-rouge">z_final = z_initial*26 + w + Q</code>.</p>

<p>Changes to x and y are irrelevant, as they will be zeroed in the next block (both Type I and Type II blocks set x and y to zero before doing anything with them).</p>

<p><strong>This process looks like appending a digit in base 26.</strong></p>

<p>Sticking to base 10 for a minute, how would we turn z=123 into z=1234. Well, we’d have to multiply 123 by 10 to get 1230, then add the 4 to get 1234.</p>

<p>Similarly, <code class="language-plaintext highlighter-rouge">z_final = z_initial*26 + w + Q</code> , considered in base 26, has the effect of <strong>appending the digit (w + Q) to the end of the digits of z_initial.</strong></p>

<p><strong>Type I blocks append the digit to the base-26 representation of z.</strong></p>

<h4 id="type-ii-block">Type II Block</h4>

<p>A Type II block looks very similar to a Type I block, but the differences are important!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inp w
mul x 0
add x z
mod x 26
div z 26
add x P
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y Q
mul y x
add z y
</code></pre></div></div>

<p>Observing my input, I noticed the following are true for all Type II blocks:</p>

<ul>
  <li>-17 &lt; P &lt;= 0</li>
  <li>0 &lt; Q &lt; 17</li>
</ul>

<p>Understanding the block follows the same logic as before:</p>

<p>If we look at lines 2 and 9, we see again that x and y are zeroed before they are used.</p>

<p>Lines 3, 4 and 6 will update the value of x such that x = z mod 26 + P.</p>

<p>Note that line 5 will set z = z//26. In a type I block, this line did nothing!</p>

<p>Line 7 checks whether w == z mod 26 + P. w is the latest input, which is a digit from the model number. Since P is always less than or equal to 0, it is possible that this equality is true, depending on the values of z and w.</p>

<h5 id="case-a-w--z-mod-26--p">Case A: w == z mod 26 + P</h5>

<p>Line 7 sets x=1.</p>

<p>Line 8 sets x=0.</p>

<p>Lines 9-12 will set y = 1, so line 13 will do nothing.</p>

<p>Lines 14-17 will set y = 0, so line 18 will do nothing.</p>

<p>In Case A, the overall effect of the block is to set <code class="language-plaintext highlighter-rouge">**z_final = z_initial//26**</code>.</p>

<p><strong>This process is removing the final digit in base 26.</strong></p>

<p>Again we can compare to base-10. If we take the number 1234 and want to change it to 123, all we have to do is divide by 10 and round down. 1234//10 gives 123.</p>

<p>Note that 6//10 = 0, so a single-digit number gets reduced to 0 rather than made into a “zero digit number”, whatever that would mean.</p>

<p><strong>In Case A, Type II blocks remove the final digit of the base-26 representation of z.</strong> <strong>If the base-26 representation of z only has one digit, then the block will set z to zero.</strong></p>

<h5 id="case-b-w--z-mod-26--p">Case B: w != z mod 26 + P</h5>

<p>Line 7 sets x=0.</p>

<p>Line 8 sets x=1.</p>

<p>Lines 9-12 will set y = 26, so line 13 will set z = 26*z</p>

<p>Lines 14-17 will set y = w + Q.</p>

<p>Line 18 will set z = z + w + Q.</p>

<p>In Case B, the overall effect of the block is to set <code class="language-plaintext highlighter-rouge">**z_final = (z_initial//26)*26 + w + Q**</code>.</p>

<p>This is replacing the final digit. Again we can imagine the base-10 situation. What if we want to turn 1234 into 1237. Well first we divide by 10 and round down, 1234//10 gives us 123. Then we multiply by 10 to give us 1230. Then we add z.</p>

<p><strong>In Case B, Type II blocks replace the final digit of the base-26 representation of z.</strong></p>

<h4 id="which-model-numbers-will-be-valid">Which model numbers will be valid?</h4>

<p>Now we can approach the question of when a model number will be valid. For a 14-digit model number to be validated by MONAD, the program must output z=0 when we input the digits of the model number as the inputs to the 14 blocks in MONAD.</p>

<p>We know that Type I blocks add a digit to the base-26 representation of z.</p>

<p>We know that Type II blocks either remove a digit from the base-26 representation of z (Case A), or replace the final digit with a new digit (Case B).</p>

<p>z=0 when MONAD starts. If we want z=0 at the end, we need to remove any digits that get added by Type I blocks. For that to happen, <strong>every Type II block must follow Case A.</strong></p>

<p>This means for every Type II block, we need <strong>w == z mod 26 + R</strong></p>

<ul>
  <li>w is the input digit, taken from the model number.</li>
  <li>z mod 26 is the final digit of the base-26 representation of z
    <ul>
      <li>Base-10 example: 1234 mod 10 is the remainder when 1234 is divided by 10.</li>
      <li>1234 mod 10 = 4 , i.e. the final digit of 1234</li>
    </ul>
  </li>
  <li>R is hard-coded in the particular Type II block we are looking at.</li>
</ul>

<p><strong>Simultaneous Equations To The Rescue</strong></p>

<p>Now we need to read through each block of MONAD, keeping track of the value of z as we do so. We’re going to assume that w == z mod 26 + R is true every time we hit a Type II block.</p>

<p>Let’s say that our 14 digit model number is abcdefghijklmn , where each letter represents a single digit of the number.</p>

<p>Here is the situation for the first 6 blocks of my particular input:</p>

<table>
  <thead>
    <tr>
      <th>Block #</th>
      <th>Input digit</th>
      <th>Block Type</th>
      <th>P</th>
      <th>Q</th>
      <th>Case A condition</th>
      <th>base-26 digits of z_final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>–</td>
      <td>–</td>
      <td>–</td>
      <td>–</td>
      <td>–</td>
      <td>[0]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>a</td>
      <td>I</td>
      <td>13</td>
      <td>13</td>
      <td>–</td>
      <td>[a+13]</td>
    </tr>
    <tr>
      <td>2</td>
      <td>b</td>
      <td>I</td>
      <td>11</td>
      <td>10</td>
      <td>–</td>
      <td>[a+13, b+10]</td>
    </tr>
    <tr>
      <td>3</td>
      <td>c</td>
      <td>I</td>
      <td>15</td>
      <td>5</td>
      <td>–</td>
      <td>[a+13, b+10, c+5]</td>
    </tr>
    <tr>
      <td>4</td>
      <td>d</td>
      <td>II</td>
      <td>-11</td>
      <td>14</td>
      <td>d = c+5+-11<br />(d = c-6)</td>
      <td>[a+13,b+10]</td>
    </tr>
    <tr>
      <td>5</td>
      <td>e</td>
      <td>I</td>
      <td>14</td>
      <td>5</td>
      <td>–</td>
      <td>[a+13,b+10, e+5]</td>
    </tr>
    <tr>
      <td>6</td>
      <td>f</td>
      <td>II</td>
      <td>0</td>
      <td>15</td>
      <td>f = e+5+0<br />(f = e+5)</td>
      <td>[a+13,b+10]</td>
    </tr>
  </tbody>
</table>

<p>Every time we encounter a Type II block, we get an equation relating two of the input digits.</p>

<h4 id="solving-the-puzzle">Solving the Puzzle</h4>

<p>At the end of the process we will have 7 equations for 14 unknown digits. This means there is no unique solution. But that’s fine - there are many possible valid model numbers.</p>

<p>We know that the digits can only be integers between 0 and 9 inclusive.</p>

<p>To find the <strong>smallest</strong> valid model number and solve part 1, we simply need to make the digits as small as possible while satisfying the equations.</p>

<ul>
  <li>d = c - 6
    <ul>
      <li>Since a digit cannot be negative, the lowest possible value of c would be 6, and the lowest possible value of d would be 0.</li>
    </ul>
  </li>
  <li>f = e + 5
    <ul>
      <li>The lowest value of f would be 5 and the lowest value of e would be 0.</li>
    </ul>
  </li>
</ul>

<p>The opposite logic will give us the digits of the <strong>largest</strong> valid model number:</p>

<ul>
  <li>d = c - 6
    <ul>
      <li>Since a digit cannot be higher than 9, the highest possible value of c would be 9, and the highest possible value of d would be 3.</li>
    </ul>
  </li>
  <li>f = e + 5
    <ul>
      <li>The highest value of f would be 9 and the highest value of e would be 4.</li>
    </ul>
  </li>
</ul>

<p>And thus the solution is in reach. I continued the table above, covering all 14 blocks of my input, created and solved 7 equations, and wrote down my answer.</p>

<p>No code was required! Now of course you could make certain assumptions about the input and write a solver, but the problem here depends sensitively on the details of the input. Without checking other people’s puzzle inputs, I can’t tell whether MONAD always uses base 26, whether it always splits neatly into 14 blocks, and so on. I’m sure that the puzzle inputs follow a strict pattern, but the point here is to reverse engineer the solution from the MONAD problem. This puzzle isn’t about coding a solution, it’s about reading, understanding and reverse-engineering someone else’s code.</p>

<h2 id="day-25---sea-cucumber">Day 25 - <a href="https://adventofcode.com/2021/day/25">Sea Cucumber</a></h2>

<h3 id="thoughts-4">Thoughts</h3>

<p>After some serious brain work on days 21-24, we get a light, refreshing single-part puzzle for Christmas Day, to round out Advent of Code 2021.</p>

<p>Sea cucumbers live on a grid.</p>

<p>Sea cucumbers come in two herds. An east-facing sea cucumber (&gt;) always moves east. A south-facing sea cucumber (v) always moves south.</p>

<p>Each step, the east-facing herd simultaneously try to move one square to the east, then the south-facing herd simultaneously try to move one square to the south.</p>

<p>A sea cucumber can only move into an unoccupied (.) space. If the space a sea cucumber would like to move to is occupied by another sea cucumber, it will not move on this step.</p>

<p>Sea cucumbers live in a toroidal space. If an east-facing cucumber reaches the eastmost edge of their row, on the next step they will try to move to the westmost position in that row. Likewise, if a south-facing cucumber reaches the southmost edge of their column, on the next step they will try to move to the northmost position in that column.</p>

<p>The question is, given an input grid, how many steps are required before no sea cucumber can move?</p>

<p>The code below attacks this problem without any particular elegance. The function <code class="language-plaintext highlighter-rouge">advance</code> will advance the grid by a single step, following the rules laid out above. The function <code class="language-plaintext highlighter-rouge">find_stability</code> will check after each step whether the grid has remained unchanged. If the grid hasn’t changed, <code class="language-plaintext highlighter-rouge">find_stability</code> will return the number of steps so far.</p>

<h3 id="python-code-3">Python Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">splitlines</span><span class="p">()</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

<span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">height</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">grid1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span><span class="o">==</span><span class="s">'&gt;'</span><span class="p">:</span>
                <span class="n">destination</span> <span class="o">=</span> <span class="n">row</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">width</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                    <span class="n">grid1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span><span class="s">'.'</span>
                    <span class="n">grid1</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">width</span><span class="p">]</span> <span class="o">=</span> <span class="s">'&gt;'</span>

    <span class="n">grid2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">grid1</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span><span class="o">==</span><span class="s">'v'</span><span class="p">:</span>
                <span class="n">destination</span> <span class="o">=</span> <span class="n">grid1</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">height</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                    <span class="n">grid2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'.'</span>
                    <span class="n">grid2</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">height</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">'v'</span>
    
    <span class="k">return</span> <span class="n">grid2</span>

<span class="k">def</span> <span class="nf">find_stability</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">stable</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">stable</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">newgrid</span> <span class="o">=</span> <span class="n">advance</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newgrid</span> <span class="o">==</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">stable</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">newgrid</span>
    
    <span class="k">return</span> <span class="n">i</span>

<span class="k">print</span><span class="p">(</span><span class="n">find_stability</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</code></pre></div></div>

  </div><a class="u-url" href="/2022/04/17/advent-of-code-2021-days-21-25.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Dave Bartram Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Dave Bartram Blog</li><li><a class="u-email" href="mailto:david.bartram@gmail.com">david.bartram@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/davidbartram"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">davidbartram</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Lessons I&#39;m learning as a: Software platform engineer, Tabletop roleplayer, Lifelong lover of maths &amp; science</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
